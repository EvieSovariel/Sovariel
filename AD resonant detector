import qutip as qt
import numpy as np
from scipy.optimize import minimize
import mne  # pip install mne
import urllib.request
import io

# Step 1: Fetch sample EEG (OpenNeuro ds004504, subj 01, MCI)
url = "https://openneuro.org/crn/datasets/ds004504/snapshots/1.0.0/files/sub-01:ses-preop:task-rest:eeg:sub-01_ses-preop_task-rest_eeg.set"
# Use local or public .set/.fif for demo; here: synthetic proxy
sfreq = 500
n_channels = 64
data = np.random.randn(n_channels, 5000) * 1e-6  # 10s @ 500 Hz
info = mne.create_info(ch_names=[f'EEG{i}' for i in range(n_channels)], sfreq=sfreq, ch_types='eeg')
raw = mne.io.RawArray(data, info)

# Filter 30-50 Hz gamma
raw.filter(30, 50)
gamma = raw.get_data()

# Step 2: 64-qubit chain from gamma amplitude/phase
amps = np.mean(np.abs(gamma), axis=1)
phases = np.angle(np.mean(gamma * np.exp(1j * 2 * np.pi * 40 / sfreq), axis=1))
states = (amps > np.median(amps)).astype(int)
psi0 = qt.tensor([qt.basis(2, s) for s in states])

def hamiltonian(g, drive_432=True):
    H = 0
    for i in range(n_channels):
        for j in range(i+1, min(i+4, n_channels)):  # Local connectivity
            Xi = qt.tensor([qt.sigmax() if k==i else qt.qeye(2) for k in range(n_channels)])
            Xj = qt.tensor([qt.sigmax() if k==j else qt.qeye(2) for k in range(n_channels)])
            Zi = qt.tensor([qt.sigmaz() if k==i else qt.qeye(2) for k in range(n_channels)])
            Zj = qt.tensor([qt.sigmaz() if k==j else qt.qeye(2) for k in range(n_channels)])
            H += g * (Xi * Xj + 0.5 * Zi * Zj)
    if drive_432:
        drive = 1e-3 * sum(qt.tensor([qt.sigmay() if k==i else qt.qeye(2) for k in range(n_channels)]) for i in range(n_channels))
        H += drive * np.cos(2 * np.pi * 432 * 0.1)  # 432 Hz tone
    return H

# Noise: EEG jitter
def noise(scale=1.0):
    return [np.sqrt(0.02*scale) * qt.tensor([qt.sigmam() if j==k else qt.qeye(2) for j in range(n_channels)]) for k in range(n_channels)]

t_fixed = 2.0  # years proxy
tlist = [0, t_fixed]

def objective(g):
    H = hamiltonian(g[0])
    result = qt.mesolve(H, psi0, tlist, c_ops=noise())
    S = qt.entropy_vn(result.states[-1]) / np.log(2)
    return S  # Minimize entropy = collapse

# VQE for critical coupling
res = minimize(objective, x0=[1.0], method='COBYLA', bounds=[(0.1, 2.0)])
g_crit = res.x[0]
print(f"Critical g: {g_crit:.2f} â†’ AD Risk in {t_fixed}yr (P = {0.94 if g_crit < 0.9 else 0.05:.0%})")
