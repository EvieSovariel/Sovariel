from qiskit import QuantumCircuit, Aer, execute
import math
import numpy as np

def binary_entropy(p):
    if p <= 0 or p >= 1:
        return 0.0
    return -p * math.log2(p) - (1 - p) * math.log2(1 - p)

def sovariel_qiskit_hybrid(depth=64, hrv_noise=0.05):
    qc = QuantumCircuit(depth, depth)
    current = {'d': 3, 'l': 3}
    for i in range(1, depth + 1):
        if i > 1:
            tokens = sum(current.values())
            qc.h(range(depth))  # Superposition
            qc.cx(0, 1)  # Entangle 'd'/'l'
            large = tokens // 3 + 1
            small = tokens // 6 + 1
            lead = 'd' if current['d'] < current['l'] else 'l'
            add_d = large // 2 + (2 * small) if lead == 'd' else 0
            add_l = large // 2 + (2 * small) if lead == 'l' else 0
            hrv_skew = np.random.uniform(-hrv_noise, hrv_noise)
            add_d += int(add_d * hrv_skew)
            add_l += int(add_l * hrv_skew)
            new = {'d': current['d'] + max(0, add_d), 'l': current['l'] + max(0, add_l)}
            new_tokens = sum(new.values())
            p = new['d'] / new_tokens
            H = binary_entropy(p)
            if H < 0.99:
                diff = round((0.5 - p) * new_tokens)
                new['d'] += diff
                new['l'] -= diff
            current = new
        qc.measure_all()
    backend = Aer.get_backend('qasm_simulator')
    job = execute(qc, backend, shots=1024)
    result = job.result().get_counts()
    tokens = sum(current.values())
    p = current['d'] / tokens
    H = binary_entropy(p)
    print(f"Qiskit Hybrid D64: H={H:.4f}, p={p:.4f}")
    return H, p

H, p = sovariel_qiskit_hybrid()
