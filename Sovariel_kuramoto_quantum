---

## File: sovariel_kuramoto_quantum.py (Updated w/ GHZ n=5)

```python
#!/usr/bin/env python3
"""
Sovariel Quantum Kuramoto Fusion: Orch-OR Microtubule Dynamics Sim
Extends classical Kuramoto with quantum bias from QuTiP shots for resonance kicks.
Now with entanglement modes (Hadamard/Bell/GHZ), bimodal HRV freqs, role-swap logic, and adaptive damping.
Author: Evie Robinson & Grok 3 (xAI) | 2025
"""

import numpy as np
import qutip as qt
from qutip import concurrence
import argparse
import os

def generate_quantum_bias(n_shots=1024, entangle_type='none', ghz_n=5, deco_gamma=0.001, seed=42):
    """Generate Q from Hadamard, Bell, or GHZ superposition (Orch-OR collapse proxy)."""
    np.random.seed(seed)
    if entangle_type == 'none':
        hadamard = (1 / np.sqrt(2)) * qt.Qobj([[1, 1], [1, -1]])
        psi0 = qt.basis(2, 0)
        psi = hadamard * psi0
        prob1 = abs(psi[1, 0])**2  # Ideal 0.5
        counts1 = np.random.binomial(n_shots, prob1)
        Q = counts1 / n_shots
    elif entangle_type == 'bell':
        # Bell state for entanglement
        bell = (qt.tensor(qt.basis(2,0), qt.basis(2,0)) + qt.tensor(qt.basis(2,1), qt.basis(2,1))) / np.sqrt(2)
        rho = bell * bell.dag()
        # Simple deco: amplitude damping gamma=deco_gamma over t=1
        c_ops = [np.sqrt(deco_gamma) * qt.tensor(qt.sigmam(), qt.qeye(2)), np.sqrt(deco_gamma) * qt.tensor(qt.qeye(2), qt.sigmam())]
        H = qt.qzero(rho.dims)
        result = qt.mesolve(H, rho, [0, 1.0], c_ops=c_ops)
        rho_dec = result.states[-1]
        C = concurrence(rho_dec)
        # Base Q from single shot + C multiplier
        hadamard = (1 / np.sqrt(2)) * qt.Qobj([[1, 1], [1, -1]])
        psi0 = qt.basis(2, 0)
        psi = hadamard * psi0
        prob1 = abs(psi[1, 0])**2
        counts1 = np.random.binomial(n_shots, prob1)
        Q_base = counts1 / n_shots
        Q = Q_base * C
    elif entangle_type == 'ghz':
        # GHZ state for n=ghz_n
        dims = [2] * ghz_n
        zero_all = qt.tensor(*[qt.basis(2, 0) for _ in range(ghz_n)])
        one_all = qt.tensor(*[qt.basis(2, 1) for _ in range(ghz_n)])
        psi_ghz = (zero_all + one_all).unit()
        rho = psi_ghz * psi_ghz.dag()
        # Deco: Local amplitude damping γ=deco_gamma over t=1
        c_ops = [np.sqrt(deco_gamma) * qt.tensor( *([qt.qeye(2)]*i + [qt.sigmam()] + [qt.qeye(2)]*(ghz_n-i-1)) ) for i in range(ghz_n)]
        H = qt.qzero(rho.dims)
        result = qt.mesolve(H, rho, [0, 1.0], c_ops=c_ops)
        rho_dec = result.states[-1]
        # Approx concurrence for multi-qubit (pairwise avg)
        C_avg = np.mean([concurrence(qt.ptrace(rho_dec, [i,j])) for i in range(ghz_n) for j in range(i+1, ghz_n)])
        # Base Q + C multiplier
        hadamard = (1 / np.sqrt(2)) * qt.Qobj([[1, 1], [1, -1]])
        psi0 = qt.basis(2, 0)
        psi = hadamard * psi0
        prob1 = abs(psi[1, 0])**2
        counts1 = np.random.binomial(n_shots, prob1)
        Q_base = counts1 / n_shots
        Q = Q_base * C_avg
    large = 10000
    add_d = int(Q * large)
    d_bias = add_d / large  # [0,1] normalized
    return Q, d_bias

def kuramoto_quantum_sim(N=100, K_base=1.0, T=100.0, dt=0.01, Delta=1.0, gamma=0.1, bimodal=False, entangle_type='none', ghz_n=5, deco_gamma=0.001, role_swap_threshold=0.4, window=10, adaptive_damping=False, alpha=2.0, seed=42):
    """Full sim: Classical Kuramoto + quantum resonance delta + all tweaks."""
    np.random.seed(seed)
    steps = int(T / dt)
    
    # Freqs
    if bimodal:
        neural = np.random.normal(40, Delta, N//2)
        cardiac = np.random.lognormal(np.log(0.1), 0.2, N//2)  # RR interval proxy
        omegas = np.concatenate([neural, cardiac])
    else:
        omegas = np.random.normal(40, Delta, N)
    theta = np.random.uniform(0, 2*np.pi, N)
    
    # Quantum bias
    Q, d_bias = generate_quantum_bias(n_shots=1024, entangle_type=entangle_type, ghz_n=ghz_n, deco_gamma=deco_gamma, seed=seed)
    K_q = K_base * Q
    
    # Histories
    R_history = np.zeros(steps)
    resonance_history = np.zeros(steps)
    t = 0.0
    r_window = []
    
    for step in range(steps):
        # Mean-field coupling
        sin_terms = np.sin(np.subtract.outer(theta, theta))
        mean_field = (K_q / N) * np.sum(sin_terms, axis=1)
        
        # Global phase
        psi_mean = np.angle(np.mean(np.exp(1j * theta)))
        
        # Adaptive damping
        if adaptive_damping and step > 0:
            gamma_eff = gamma * np.exp(-alpha * R_history[step-1])
        else:
            gamma_eff = gamma
        
        # Resonance delta: Orch-OR pull w/ damping
        damping = np.exp(-gamma_eff * t)
        resonance_delta = d_bias * damping * np.cos(psi_mean - theta)
        
        # Update
        dtheta = omegas + mean_field + resonance_delta
        theta += dtheta * dt
        theta = np.mod(theta, 2 * np.pi)
        t += dt
        
        # Order param
        R = np.abs(np.mean(np.exp(1j * theta)))
        R_history[step] = R
        resonance_history[step] = np.mean(np.abs(resonance_delta))
        
        # Role-swap logic
        r_window.append(R)
        if len(r_window) > window:
            r_window.pop(0)
        if len(r_window) == window and np.mean(r_window) < role_swap_threshold:
            # Find low-coherence: phase diff > pi/2 from psi
            phase_diffs = np.abs(np.angle(np.exp(1j * (theta - psi_mean))))
            low_idx = np.where(phase_diffs > np.pi / 2)[0]
            if len(low_idx) > 0:
                num_low = len(low_idx)
                theta[low_idx] = np.random.uniform(0, 2*np.pi, num_low)
                omegas[low_idx] += Q * np.random.normal(0, Delta, num_low)  # Q-weighted shift
            r_window = []  # Reset window after swap
    
    # Save data
    os.makedirs('data', exist_ok=True)
    np.save('data/R_history.npy', R_history)
    np.save('data/resonance_history.npy', resonance_history)
    np.save('data/omegas.npy', omegas)  # For bimodal check
    
    return Q, K_q, R_history, resonance_history

def main():
    parser = argparse.ArgumentParser(description="Sovariel Quantum Kuramoto Sim")
    parser.add_argument('--N', type=int, default=100, help='Oscillator count')
    parser.add_argument('--K', type=float, default=1.0, help='Base coupling')
    parser.add_argument('--T', type=float, default=100.0, help='Sim time (s)')
    parser.add_argument('--gamma', type=float, default=0.1, help='Base deco rate')
    parser.add_argument('--n_shots', type=int, default=1024, help='Qubit shots')
    parser.add_argument('--bimodal', action='store_true', help='Enable HRV bimodal freqs')
    parser.add_argument('--entanglement_mode', type=str, default='none', choices=['none', 'bell', 'ghz'], help='Entanglement: none|bell|ghz')
    parser.add_argument('--ghz_n', type=int, default=5, help='GHZ qubit count (for ghz mode)')
    parser.add_argument('--deco_gamma', type=float, default=0.001, help='Entanglement deco rate')
    parser.add_argument('--role_swap_threshold', type=float, default=0.4, help='R thresh for swaps')
    parser.add_argument('--window', type=int, default=10, help='Monitoring window steps')
    parser.add_argument('--adaptive_damping', action='store_true', help='Enable adaptive γ_eff = γ exp(-α R)')
    parser.add_argument('--alpha', type=float, default=2.0, help='Adaptive sensitivity')
    parser.add_argument('--seed', type=int, default=42, help='RNG seed')
    args = parser.parse_args()
    
    Q, K_q, R_hist, res_hist = kuramoto_quantum_sim(
        N=args.N, K_base=args.K, T=args.T, gamma=args.gamma, 
        bimodal=args.bimodal, entangle_type=args.entanglement_mode, ghz_n=args.ghz_n, deco_gamma=args.deco_gamma,
        role_swap_threshold=args.role_swap_threshold, window=args.window,
        adaptive_damping=args.adaptive_damping, alpha=args.alpha, seed=args.seed
    )
    
    print(f"Quantum Q: {Q:.4f} | Effective K_q: {K_q:.4f}")
    print(f"Final R: {R_hist[-1]:.4f} | Max R: {np.max(R_hist):.4f}")
    print(f"Avg resonance delta: {np.mean(res_hist):.4f}")

if __name__ == "__main__":
    main()
