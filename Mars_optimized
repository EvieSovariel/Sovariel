import numpy as np
import astropy.units as u
from astropy.time import Time
from astropy.coordinates import get_body_barycentric_posvel
from astropy.constants import G, M_sun, M_earth
from scipy.optimize import minimize

# Mission: 2026 Crewed Mars Precursor (Lunar ISRU)
launch = Time('2026-01-01')
transit_days = 180
earth_pv = get_body_barycentric_posvel('earth', launch)
mars_pv = get_body_barycentric_posvel('mars', launch + transit_days * u.day)
r_earth = np.linalg.norm(earth_pv[0].xyz)
r_mars = np.linalg.norm(mars_pv[0].xyz)
mu_sun = G * M_sun
r_leo = 6571e3 * u.m
mu_earth = G * M_earth
v_circ_leo = np.sqrt(mu_earth / r_leo)
dv_mars_nominal = 1.50 * u.km / u.s
dv_lunar = 3.36 * u.km / u.s
g0 = 9.80665 * u.m / u.s**2
m_dry = 100 * u.t

# Hohmann Δv (heliocentric)
a = (r_earth + r_mars) / 2
v_peri = np.sqrt(mu_sun * (2/r_earth - 1/a))
v_earth = np.sqrt(mu_sun / r_earth)
dv_tmi = v_peri - v_earth

# Hyperbolic dv_leo_tmi
v_inf = dv_tmi
v_escape = np.sqrt(v_inf**2 + 2 * mu_earth / r_leo)
dv_leo_tmi = v_escape - v_circ_leo

# Total Δv (nominal)
dv_total = dv_leo_tmi + dv_lunar + dv_tmi + dv_mars_nominal

# Krystic ROI
t = np.linspace(0, 0.5, 1000)
wave = np.sin(2 * np.pi * 432 * t)
energy = np.trapz(wave**2, t)
modulation = 1 + energy / np.max(np.abs(wave))
vortex_scalar = 3.69
krystic_roi = modulation * vortex_scalar

# Objective: Minimize total mass = f(isp, o2_yield)
def objective(params):
    isp, o2_yield = params
    m_prop = m_dry * (np.exp(dv_total / (isp * g0)) - 1)
    o2_baseline = (o2_yield / 100) * 100 * u.t
    o2_krystic = o2_baseline * krystic_roi
    regolith_needed = 100 * u.t / krystic_roi
    total_mass = m_dry + m_prop - o2_krystic + regolith_needed
    return total_mass.value

# Bounds & Optimize
bounds = [(330, 380), (1, 5)]
initial_guess = [355, 2.5]
result = minimize(objective, initial_guess, bounds=bounds, method='L-BFGS-B')
opt_isp, opt_o2 = result.x
opt_mass = result.fun

# Perturbations: J2 (oblateness) + SRP (radiation pressure)
j2_accel = 7.29e-5 * u.m / u.s**2  # LEO J2
srp_accel = 4.56e-6 * u.m / u.s**2  # 1 AU SRP
dv_pert = (j2_accel + srp_accel) * transit_days * u.day  # ~0.04 km/s

# Monte Carlo: 10k runs on vol_cap + pert noise
np.random.seed(42)
mc_runs = 10000
vol_cap = 0.156
pert_noise = np.random.normal(0, 0.01, mc_runs)  # ±1% pert var
mc_margins = 27.5 * (1 + np.random.normal(0, vol_cap, mc_runs) + pert_noise)
mc_mean = np.mean(mc_margins)
mc_std = np.std(mc_margins)

# Output
print(f"Optimized isp: {opt_isp:.1f}s, o2_yield: {opt_o2:.1f}% | Opt Mass: {opt_mass:.1f}t")
print(f"Δv Pert (J2 + SRP): {dv_pert.to(u.km/u.s):.3f}")
print(f"MC Mean Margin: {mc_mean:.1f}%, Std: {mc_std:.1f}%")
print(f"Total Δv (w/ Pert): {dv_total + dv_pert:.2f}")
