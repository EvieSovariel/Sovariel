import numpy as np
import astropy.units as u
from astropy.time import Time
from astropy.coordinates import get_body_barycentric_posvel
from astropy.constants import G, M_sun, M_earth
from scipy.optimize import minimize
from pulp import LpMinimize, LpProblem, LpVariable, lpSum, value

# Mission: 2026 Crewed Mars Precursor (Lunar ISRU)
launch = Time('2026-01-01')
transit_days = 180
earth_pv = get_body_barycentric_posvel('earth', launch)
mars_pv = get_body_barycentric_posvel('mars', launch + transit_days * u.day)
r_earth = np.linalg.norm(earth_pv[0].xyz)
r_mars = np.linalg.norm(mars_pv[0].xyz)
mu_sun = G * M_sun
r_leo = 6571e3 * u.m
mu_earth = G * M_earth
v_circ_leo = np.sqrt(mu_earth / r_leo)
dv_mars_nominal = 1.50 * u.km / u.s
dv_lunar = 3.36 * u.km / u.s
g0 = 9.80665 * u.m / u.s**2
m_dry = 100 * u.t

# Hohmann Δv (heliocentric)
a = (r_earth + r_mars) / 2
v_peri = np.sqrt(mu_sun * (2/r_earth - 1/a))
v_earth = np.sqrt(mu_sun / r_earth)
dv_tmi = v_peri - v_earth

# Hyperbolic dv_leo_tmi
v_inf = dv_tmi
v_escape = np.sqrt(v_inf**2 + 2 * mu_earth / r_leo)
dv_leo_tmi = v_escape - v_circ_leo

# Total Δv (nominal)
dv_total = dv_leo_tmi + dv_lunar + dv_tmi + dv_mars_nominal

# Planetary Gravity Perturbs (J2 + n-body approx)
j2_accel = 7.29e-5 * u.m / u.s**2
n_body_accel = 1e-6 * u.m / u.s**2  # Approx from Mars/Earth
dv_pert_grav = (j2_accel + n_body_accel) * transit_days * u.day

# Aero Var on Mars (density ±10%)
atm_var = 0.10
dv_mars_var = dv_mars_nominal * (1 + np.random.normal(0, atm_var))  # Sample

# Krystic ROI
t = np.linspace(0, 0.5, 1000)
wave = np.sin(2 * np.pi * 432 * t)
energy = np.trapz(wave**2, t)
modulation = 1 + energy / np.max(np.abs(wave))
vortex_scalar = 3.69
krystic_roi = modulation * vortex_scalar

# PuLP Resource Optimization (Min Mass for Fixed Payload)
prob = LpProblem("ISRU_Opt", LpMinimize)
o2_yield = LpVariable("o2_yield", 1, 5)
isp = LpVariable("isp", 330, 380)
m_prop = m_dry * (np.exp(dv_total / (isp * g0)) - 1)
o2_baseline = (o2_yield / 100) * 100 * u.t
o2_krystic = o2_baseline * krystic_roi
regolith_needed = 100 * u.t / krystic_roi
total_mass = m_dry + m_prop - o2_krystic + regolith_needed
prob += total_mass  # Minimize
prob.solve()

opt_o2 = value(o2_yield)
opt_isp = value(isp)
opt_mass = value(total_mass)

# Monte Carlo: 10k runs on vol_cap + pert + atm var
np.random.seed(42)
mc_runs = 10000
vol_cap = 0.156
pert_noise = np.random.normal(0, 0.01, mc_runs)
atm_noise = np.random.normal(0, 0.10, mc_runs)
mc_margins = 27.5 * (1 + np.random.normal(0, vol_cap, mc_runs) + pert_noise + atm_noise)
mc_mean = np.mean(mc_margins)
mc_std = np.std(mc_margins)

# Output
print(f"Optimized o2_yield: {opt_o2:.1f}%, isp: {opt_isp:.1f}s | Opt Mass: {opt_mass:.1f}t")
print(f"Δv Pert (Grav): {dv_pert_grav.to(u.km/u.s):.3f}")
print(f"dv_mars Var Sample: {dv_mars_var.to(u.km/u.s):.2f}")
print(f"MC Mean Margin: {mc_mean:.1f}%, Std: {mc_std:.1f}%")
print(f"Total Δv (w/ Pert): {dv_total + dv_pert_grav:.2f}")
