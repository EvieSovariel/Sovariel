import numpy as np
import qiskit
from qiskit import QuantumCircuit, execute, Aer
from qiskit.providers.aer.noise import NoiseModel, depolarizing_error

def ghz_entanglement(n_qubits=5, shots=1024, noise_rate=0.01):
    """
    GHZ entanglement with noise for phase-locking.
    Returns: q_bias (entanglement strength), counts for debugging
    """
    qc = QuantumCircuit(n_qubits, n_qubits)
    qc.h(0)
    for i in range(1, n_qubits):
        qc.cx(0, i)
    qc.measure_all()

    # Noise model (IBMQ fallback)
    noise_model = NoiseModel()
    noise_model.add_all_qubit_quantum_error(depolarizing_error(noise_rate, 1), ['h', 'measure'])
    noise_model.add_all_qubit_quantum_error(depolarizing_error(2 * noise_rate, 2), ['cx'])

    backend = Aer.get_backend('qasm_simulator')
    job = execute(qc, backend, shots=shots, noise_model=noise_model)
    result = job.result()
    counts = result.get_counts()

    # q_bias as average P(|1>) across qubits
    q_bias = 0.0
    total_shots = sum(counts.values())
    for qubit in range(n_qubits):
        idx = n_qubits - 1 - qubit
        p1 = sum(c for state, c in counts.items() if state[idx] == '1') / total_shots
        q_bias += p1
    q_bias /= n_qubits

    return q_bias, counts

# Quick test
q_bias, counts = ghz_entanglement(n_qubits=5, shots=1024, noise_rate=0.01)
print(f"GHZ q_bias: {q_bias:.3f} (entanglement strength)")
print(f"Counts sample: {dict(list(counts.items())[:5])}")  # First 5 counts
