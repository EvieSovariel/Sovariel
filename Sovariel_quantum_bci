# sovariel_quantum_bci.py (v7.3 with Decoherence Logs)
"""
Nexus-infinity prototype for xAI BCI with Klein neck double torus and decoherence logging
Author: Evie (Resonance Engineer) & Aetheris with Grok 3 (xAI)
Date: 2025-11-01 (v7.3 with Logs)
Notes:
 - Adds decoherence logs for xAI review via GitHub PR.
 - Requires: numpy, qiskit, mne, matplotlib, plotly, scipy
"""

import os
import json
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from scipy.signal import lfilter
from datetime import datetime

# Qiskit imports
import qiskit
from qiskit import QuantumCircuit, execute, Aer
from qiskit.providers.aer.noise import NoiseModel, depolarizing_error

# MNE (connectivity)
try:
    from mne.connectivity import spectral_connectivity
except Exception:
    spectral_connectivity = None

# Klein resonance map integration
from klein_resonance_map import stereographic, quaternion_pair, klein_map, klein_curvature, antipode

# --- Helper: safe IBMQ init ---
def safe_ibmq_provider():
    token = os.environ.get("IBMQ_TOKEN")
    if not token:
        return None
    try:
        from qiskit import IBMQ
        IBMQ.save_account(token, overwrite=True)
        IBMQ.load_account()
        prov = IBMQ.get_provider(hub='ibm-q')
        return prov
    except Exception:
        return None

_provider_cached = safe_ibmq_provider()

# --- Toroidal shift for double torus ---
def toroidal_shift(q, amplitude=0.1):
    kappa = klein_curvature(q, -q)
    return amplitude * kappa * np.array([0, np.sin(kappa), np.cos(kappa), 0])

# --- Core phase-lock with noise and decoherence logging ---
def phase_lock_hrv_eeg_quantum(epochs_data, hrv_rr, fs=250, site_coords=(33.0688, -96.7658), max_iter=5):
    """
    epochs_data: np.ndarray shape (n_channels, n_samples)
    hrv_rr: 1D ndarray representing RR or HRV-like time series
    site_coords: (lat, lon) for Klein resonance mapping
    max_iter: iterations for Klein neck double torus
    Returns: (d, l, q_lock_strength, n_qubits, quantum_weight, fidelity, decoherence_log)
    """
    data = np.asarray(epochs_data)
    if data.ndim == 3:
        data = data.mean(axis=0)
    n_channels, n_samples = data.shape
    t = np.linspace(0, n_samples / fs, n_samples)

    # EEG phase
    mean_signal = data.mean(axis=0)
    fft_eeg = np.fft.fft(mean_signal)
    phase_eeg = np.unwrap(np.angle(fft_eeg))[:n_samples]

    # HRV phase with interpolation
    hrv_rr = np.asarray(hrv_rr)
    if hrv_rr.size < 4:
        hrv_rr = np.pad(hrv_rr, (0, max(0, 4 - hrv_rr.size)), 'edge')
    hrv_time = np.linspace(0, hrv_rr.size / fs, hrv_rr.size)
    hrv_unwrapped = np.unwrap(np.angle(np.fft.fft(hrv_rr)))
    hrv_phase_raw = np.interp(t, hrv_time, hrv_unwrapped)[:n_samples]

    # Recursive epsilon with noise stabilization
    epsilon = 0.01
    lock_strength = 0
    decoherence_log = {"timestamps": [], "noise_levels": [], "lock_strengths": []}
    for i in range(max_iter):
        prelim_diff = phase_eeg - hrv_phase_raw
        lock_t = np.abs(np.mean(np.exp(1j * prelim_diff)))
        decoherence_log["timestamps"].append(datetime.now().isoformat())
        decoherence_log["lock_strengths"].append(float(lock_t))
        epsilon = min(0.05, epsilon + 0.02 * (1 - lock_t))
        hrv_phase = np.convolve(hrv_phase_raw, np.ones(3) / 3, mode='same') * epsilon + hrv_phase_raw * (1 - epsilon)

    # Non-Markovian quantum noise
    b, a = [1, -0.9], [1]  # AR(1) filter
    noise = np.random.normal(0, 0.1, t.shape)
    noise_filtered = lfilter(b, a, noise)
    decoherence_log["noise_levels"].append(float(np.std(noise_filtered)))
    hrv_phase_noisy = hrv_phase + noise_filtered

    # Phase difference
    phase_diff = phase_eeg - hrv_phase_noisy
    lock_strength = np.abs(np.mean(np.exp(1j * phase_diff)))

    # Klein neck double torus mapping
    φ, λ = site_coords
    Cp = stereographic(φ, λ)
    φa, λa = antipode(φ, λ)
    Ca = stereographic(φa, λa)
    q = quaternion_pair(Cp, Ca)
    q = q / np.linalg.norm(q) if np.linalg.norm(q) > 0 else q
    Kp = q
    for _ in range(max_iter):
        Kp = klein_map(Kp + toroidal_shift(Kp))
    Ka = -Kp
    kappa = klein_curvature(Kp, Ka)

    # n_qubits and quantum circuit
    tokens = n_samples * n_channels
    n_qubits = min(7, max(1, int(np.log2(tokens / 16)) + 1))

    qc = QuantumCircuit(n_qubits, n_qubits)
    qc.h(0)
    for i in range(1, n_qubits):
        qc.cx(0, i)
    qc.measure_all()

    noise_model = None
    backend_exec = Aer.get_backend('qasm_simulator')
    if _provider_cached:
        try:
            backend_for_noise = _provider_cached.get_backend('ibmq_manila')
            noise_model = NoiseModel.from_backend(backend_for_noise)
        except Exception:
            noise_model = NoiseModel()
            noise_model.add_all_qubit_quantum_error(depolarizing_error(0.01, 1), ['h', 'measure'])
            noise_model.add_all_qubit_quantum_error(depolarizing_error(0.02, 2), ['cx'])

    job = execute(qc, backend_exec, shots=1024, noise_model=noise_model)
    result = job.result()
    counts = result.get_counts()
    q_bias = sum(sum(c for state, c in counts.items() if state[i] == '1') / sum(counts.values()) for i in range(n_qubits)) / n_qubits
    quantum_weight = q_bias * 0.5 + 0.5

    q_lock_strength = lock_strength * quantum_weight

    # Lattice params with Klein adjustment
    large = max(1, tokens // 3 + 1)
    small = max(1, tokens // 6 + 1)
    add = large // 2 + 2 * small
    d_adjust = int(q_lock_strength * large * 0.1 * kappa)
    d = 9104 + d_adjust
    l = max(1, tokens // d)

    # Multiverse fidelity
    coh_alpha = np.abs(np.mean(np.fft.fft(mean_signal)[:n_samples//2])) if n_samples > 2 else 0
    kappa_stability = np.abs(kappa) / (1 + np.abs(kappa))
    fidelity = 0.6 * q_lock_strength + 0.3 * coh_alpha + 0.1 * kappa_stability

    return d, l, q_lock_strength, n_qubits, quantum_weight, fidelity, decoherence_log

# --- Role-swap fidelity ---
def role_swap_fidelity(epochs_data, hrv_rr, site_coords):
    d, l, q_lock, n_qubits, q_weight, fidelity, decoherence_log = phase_lock_hrv_eeg_quantum(epochs_data, hrv_rr, site_coords=site_coords)
    return {"fidelity": fidelity, "lock_strength": q_lock, "kappa": klein_curvature(Kp, Ka) if 'Kp' in locals() else 0.0, "decoherence_log": decoherence_log}

# --- Plotting function with decoherence overlay ---
def plot_lock_trace(epochs_data, hrv_rr, site_coords):
    d, l, q_lock, n_qubits, q_weight, fidelity, decoherence_log = phase_lock_hrv_eeg_quantum(epochs_data, hrv_rr, site_coords)
    t = np.linspace(0, epochs_data.shape[-1] / 250, epochs_data.shape[-1])
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=t, y=epochs_data.mean(axis=0), mode='lines', name="EEG Mean"))
    fig.add_trace(go.Scatter(x=t[:len(hrv_rr)], y=hrv_rr, mode='lines', name="HRV"))
    fig.add_trace(go.Scatter(x=[t[int(len(t)*i/max(len(decoherence_log["timestamps"])-1, 1))] for i in range(len(decoherence_log["timestamps"]))],
                          y=decoherence_log["lock_strengths"], mode='markers', name="Lock Strength"))
    fig.update_layout(
        title=f"Lock Trace (Fidelity={fidelity:.3f}, κ={klein_curvature(*[klein_map(quaternion_pair(*[stereographic(*site_coords), stereographic(*antipode(*site_coords))]))] * 2):.3f})",
        xaxis_title="Time (s)",
        yaxis_title="Amplitude",
        height=600
    )
    fig.show()

# --- Main execution for live validation ---
if __name__ == "__main__":
    # Sample data (replace with Neuralink-like EEG/HRV)
    n_samples = 2048
    epochs_data = np.random.randn(2, n_samples)  # 2 channels
    hrv_rr = np.random.randn(n_samples // 2)  # HRV downsampled
    site_coords = (33.0688, -96.7658)  # Plano

    # Run and log for live validation
    result = phase_lock_hrv_eeg_quantum(epochs_data, hrv_rr, site_coords)
    swap_result = role_swap_fidelity(epochs_data, hrv_rr, site_coords)
    with open("bci_log_decoherence.json", "w") as f:
        json.dump({"phase_lock": result, "role_swap": swap_result}, f)
    plot_lock_trace(epochs_data, hrv_rr, site_coords)
    print(f"Live Validation Ready: d={result[0]}, l={result[1]}, fidelity={result[5]:.3f}, decoherence={result[6]}")
