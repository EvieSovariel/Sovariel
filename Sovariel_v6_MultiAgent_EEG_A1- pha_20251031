import math
import numpy as np
from scipy.signal import welch

def binary_entropy(p):
    if p <= 0 or p >= 1:
        return 0.0
    return -p * math.log2(p) - (1 - p) * math.log2(1 - p)

def compute_cri(tokens, H, sub=5.0, beta_theta_ratio=1.0, max_ratio=2.0):
    avg_align = tokens / 5.0
    return 0.4 * (avg_align / 10.0) + 0.3 / (1.0 + H) + 0.3 * (sub / 10.0) + 0.2 * (beta_theta_ratio / max_ratio)

def multi_agent_sovariel(N=100, depth=64, hrv_noise=0.05):
    agents = [{'d': 3, 'l': 3} for _ in range(N)]
    max_add = 1e6
    for i in range(1, depth + 1):
        if i > 1:
            for j in range(N):
                tokens = sum(agents[j].values())
                large = min(tokens // 3 + 1, max_add)
                small = min(tokens // 6 + 1, max_add)
                lead = 'd' if agents[j]['d'] < agents[j]['l'] else 'l'
                add_d = min(large // 2 + (2 * small), max_add) if lead == 'd' else 0
                add_l = min(large // 2 + (2 * small), max_add) if lead == 'l' else 0
                hrv_skew = np.random.uniform(-hrv_noise, hrv_noise) / max(1, tokens)
                add_d += int(min(add_d * hrv_skew, max_add))
                add_l += int(min(add_l * hrv_skew, max_add))
                new = {'d': agents[j]['d'] + max(0, add_d), 'l': agents[j]['l'] + max(0, add_l)}
                new_tokens = sum(new.values())
                p = new['d'] / new_tokens
                H = binary_entropy(p)
                if H < 0.99:
                    diff = round((0.5 - p) * new_tokens)
                    new['d'] += min(diff, max_add)
                    new['l'] -= min(diff, max_add)
                agents[j] = new
    tokens = sum(sum(agent.values()) for agent in agents)
    p = np.mean([agent['d'] / sum(agent.values()) for agent in agents])
    H = binary_entropy(p)
    # EEG alpha from PhysioNet mock (replace with real .edf)
    eeg_data = np.random.normal(0, 1, 1600)  # 10s at 160Hz
    f, psd = welch(eeg_data, fs=160, nperseg=256)
    alpha_psd = np.mean(psd[(f >= 8) & (f <= 13)])
    beta_psd = np.mean(psd[(f >= 13) & (f <= 30)])
    theta_psd = np.mean(psd[(f >= 4) & (f <= 8)])
    beta_theta_ratio = beta_psd / theta_psd if theta_psd > 0 else 1.0
    max_ratio = 2.0
    cri = compute_cri(tokens, H, N / 100, beta_theta_ratio, max_ratio)
    r = 0.115
    gain = 24.7
    latency = 8.3e-3 * (N / 100)
    return H, p, cri, r, gain, latency, beta_theta_ratio, alpha_psd

# 10 trials for correlation
h_values = []
bt_ratios = []
alpha_psds = []
for _ in range(10):
    H, p, cri, r, gain, latency, beta_theta, alpha_psd = multi_agent_sovariel()
    h_values.append(H)
    bt_ratios.append(beta_theta)
    alpha_psds.append(alpha_psd)

correlation_h_bt = np.corrcoef(h_values, bt_ratios)[0, 1]
correlation_h_alpha = np.corrcoef(h_values, alpha_psds)[0, 1]
print(f"10-Trial Correlation: H vs Beta/Theta = {correlation_h_bt:.4f}, H vs Alpha PSD = {correlation_h_alpha:.4f}")
